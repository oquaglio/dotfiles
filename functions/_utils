# print environment
# takes a param that is a string to search for
e() {
    # Define colors
    GREEN="\033[0;32m"
    YELLOW="\033[1;33m"
    NC="\033[0m" # No Color

    # Print matched environment variables with highlighting for the search term
    printenv | grep -i --color=always "$1"

    # Count matches and print the total with color
    matches=$(printenv | grep -i -c "$1")
    printf "${YELLOW}Matches: ${GREEN}${matches}${NC}\n"
}

#display ports
dp() {
	bash -c 'netstat -tulanp' | grep -i "$1";
	printf "Matches: " && bash -c 'netstat -tulanp' | grep -i -c "$1";
}

#reload (re-source) shell config files
reload_shell_config() {
    if [ "$(basename "$SHELL")" = "zsh" ] && [ -r ~/.zshrc ]; then
	# echo "Reloading .zshrc..."
        #. ~/.zshrc
	# https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file
	echo 'Running "exec zsh"...'
	exec zsh 
    fi

    if [ "$(basename "$SHELL")" = "bash" ] && [ -r ~/.bashrc ]; then
	echo "Reloading .bashrc..."
        . ~/.bashrc
    fi

    if [ -r ~/.profile ]; then
	echo "Reloading .profile..."
        . ~/.profile
    fi
}
alias rl='reload_shell_config'

# Add dir (string) to the PATH if not already in PATH AND dir exists
# $1 (First Parameter): The directory you want to add to the path variable.
# $2 (Second Parameter): The name of the path variable to update. If this parameter is not provided, it defaults to PATH.
# Examples:
# pathadd /usr/local/myapp/bin
# pathadd /usr/local/myapp/bin MY_CUSTOM_PATH
# pathadd $HOME/.local/bin
# pathadd /home/linuxbrew/.linuxbrew/share/man MANPATH
pathadd() {
    # First parameter: directory to add
    dir_to_add="$1"
    # Second parameter: variable to update (default to PATH if not provided)
    path_var="${2:-PATH}"

    # Check if the first argument is a valid directory
    if [ -d "$dir_to_add" ]; then
        # Get the current value of the specified PATH variable
        current_path=$(eval echo \$$path_var)

        # Check if the directory is already in the PATH variable
        if [[ ":$current_path:" != *":$dir_to_add:"* ]]; then
            # Add the directory to the PATH variable
            new_path="${current_path:+"$current_path:"}$dir_to_add"
            export $path_var="$new_path"
        else
            : # echo "The directory '$dir_to_add' is already in the $path_var."
        fi
    else
        : # echo "The directory '$dir_to_add' does not exist."
    fi
}


# set env variable to dir IF dir exists
# $1 = env var
# $2 = dir
setenv() {
	if [ -d "$2" ]; then
		export $1=$2
	fi
}

contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# Function to safely source a file if it exists
source_if_exists() {
    local filename="$1"  # Capture the filename argument

    # Check if the file exists and is readable
    if [[ -r "$filename" ]]; then
        #echo "Sourcing $filename..."
        source "$filename"
    else
        echo "Error: $filename does not exist or is not readable."
    fi
}


###############################################################################
# Functions to detect file changes
#
#   Access - the last time the file was read
#   Modify - the last time the file content has been modified OR file has been
#            saved
#   Change - the last time meta data of the file was changed (e.g. permissions)
#            AND also when file is modified
#
#   Notes
#          - Linux does not track the creation time
#          - can't rely on modified time to detect new files from installs
#	         as it can remain an older time (presume from original creating
#			 time)
###############################################################################
# start find changes - set MARK modificaton time to now
sfch() {
	mkdir -p $HOME/temp
	touch -m $HOME/temp/MARK
}

# find modified files since MARK was modified
# usage:
# 	sudo fch
# 	fch ~ 		only check home(~) dir for changes
fch() {
    if [ -z "$1" ]; then
        echo "Usage: fch <path>"
        return 1
    fi

    log_dir="$HOME/logs/install"
    mkdir -p -- "$log_dir" || { echo "Failed to create log directory: $log_dir"; return 1; }

    current_datetime=$(date +"%Y%m%d-%H%M%S")
    current_datetime_full=$(date +"%Y-%m-%d %H:%M:%S")
    log_filename="${current_datetime}-file-changes.log"
    log_filepath="$log_dir/$log_filename"

    echo "Writing changed files to: '$log_filepath'"

    # Attempt to get the modified time of MARK and handle errors
    mark_filepath="$HOME/temp/MARK"
    if ! date_of_mark=$(date -r "$mark_filepath" +"%Y-%m-%d %H:%M:%S" 2>/dev/null); then
        echo "The mark file '$mark_filepath' does not exist or cannot be read."
        return 1
    fi

    echo "Searching for files modified after $date_of_mark at $current_datetime_full..."

    # Run the find command and write results to the log file and stdout
    # -newerct = inode status change time 
    # -newerat = access time 
    # -newermt = modified time
    # -newerBt = birth time
    # addition to -newermt for modification time. It uses a logical OR (-o) between these
    # conditions, meaning it will find files that meet any of these criteria.
    {
        find "${1:-$HOME}" -type d \( -name .mozilla -o -name .cache \) -prune -o \
            -path /mnt -prune -o \
            -path /dev -prune -o \
            -path /var/cache -prune -o \
            -path /run -prune -o \
            -path /tmp -prune -o \
            -path /sys -prune -o \
            -path /proc -prune -o \
            \( -newermt "$date_of_mark" -o -newerct "$date_of_mark" \) \
            -printf "[Acc: %AY-%Am-%Ad %AH:%AM:%.2AS] [Mod: %TY-%Tm-%Td %TH:%TM:%.2TS] [Chg: %CY-%Cm-%Cd %CH:%CM:%.2CS] %p\n"
    } | tee -a "$log_filepath"

    echo "Done. File changes written to: '$log_filepath'"
}
