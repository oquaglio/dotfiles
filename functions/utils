# print environment
# takes a param that is a string to search for
e() {
    # Define colors
    GREEN="\033[0;32m"
    YELLOW="\033[1;33m"
    NC="\033[0m" # No Color

    # Print matched environment variables with highlighting for the search term
    printenv | grep -i --color=always "$1" | sort

    # Count matches and print the total with color
    matches=$(printenv | grep -i -c "$1")
    printf "${YELLOW}Matches: ${GREEN}${matches}${NC}\n"
}

# conn - Display active TCP/UDP connections with owning process and user
#
# This function wraps `ss -lntup` to list all active and listening network sockets,
# showing the associated process ID and user (OWNER) for each entry.
#
# Features:
# - Works on modern Linux distributions (no need for deprecated `netstat`)
# - Adds an OWNER column by extracting the PID from each `ss` line and resolving
#   the user with `ps`
# - Supports optional search term filtering (e.g. port, PID, process name)
# - Writes output to a temporary file to count matches and cleanly format results
#
# Usage:
#   dp                → list all active TCP/UDP sockets with user info
#   dp 8080           → filter only entries matching '8080' (case-insensitive)
#
# Requirements:
# - `ss` (from `iproute2`) must be installed (default on most distros)
# - `sudo` is used to ensure all processes (not just user-owned) are visible
#
# Example Output:
#   Netid State   Recv-Q Send-Q Local Address:Port  Peer Address:Port  Process           OWNER
conn() {
    local search_term="$1"
    local tmpfile="/tmp/conn_matches.log"

    # Get all TCP/UDP sockets including connected ones (no -l)
    local ss_output
    ss_output=$(sudo ss -ntup 2>/dev/null)

    # Skip if no output
    if [[ -z "$ss_output" ]]; then
        echo "No output from ss. Are there any active connections?"
        return 1
    fi

    # Optionally filter
    if [[ -n "$search_term" ]]; then
        echo "Searching for processes matching: $search_term"
        ss_output=$(echo "$ss_output" | grep -i "$search_term")
    else
        echo "Listing all active and listening connections..."
    fi

    if [[ -z "$ss_output" ]]; then
        echo "No matching connections found."
        return 0
    fi

    echo "$ss_output" | while IFS= read -r line; do
        if [[ "$line" =~ ^Netid ]]; then
            echo -e "${line}\tOWNER"
        elif [[ -n "$line" ]]; then
            local pid=$(echo "$line" | grep -oP 'pid=\K[0-9]+')
            if [[ "$pid" =~ ^[0-9]+$ ]]; then
                local owner=$(ps -o user= -p "$pid" 2>/dev/null || echo "N/A")
                echo -e "${line}\t${owner}"
            else
                echo -e "${line}\tN/A"
            fi
        fi
    done | tee "$tmpfile"

    local match_count
    match_count=$(wc -l < "$tmpfile")
    echo "Matches: $match_count"
    rm -f "$tmpfile"
}

# Function: pack
# Description: Detects available package managers, counts installed packages, and reports additional details (version, architecture, last update).
#              Supports native (e.g., apt, pacman), universal (e.g., flatpak, snap, brew), and language-specific (e.g., pip, npm) managers.
#              Uses sudo where needed for accurate counts. Designed for compatibility across Linux distros.
# Usage: Call `pack` after sourcing or run as a script. Example: `. pack.sh && pack`
# Notes:
# - Requires sudo for some managers (e.g., dpkg, rpm, dnf).
# - Add to ~/.profile or ~/.bashrc for shell availability.
# - Enhanced with version info, accurate counts, and summary table.

pack() {
    printf "Detecting package managers and counting installed packages...\n"
    printf "System Architecture: %s\n" "$(uname -m)"
    printf "Note: Some commands may prompt for sudo password for accurate counts.\n"
    printf "      Counts may include system/default packages.\n\n"

    # Helper function to check and count packages
    _check_and_count() {
        manager="$1"
        check_cmd="$2"
        count_cmd="$3"
        version_cmd="$4"
        description="$5"
        cache_file="$6" # Optional cache file for last update time (native managers)

        if command -v "$check_cmd" >/dev/null 2>&1; then
            printf "Package Manager: %s (%s)\n" "$manager" "$description"
            # Get version
            version=$(sh -c "$version_cmd" 2>/dev/null | head -n 1)
            [ -z "$version" ] && version="Unknown"
            printf "Version: %s\n" "$version"
            # Count packages
            count=$(sh -c "$count_cmd" 2>/dev/null | wc -l | tr -d '[:space:]')
            [ -z "$count" ] || [ "$count" -eq 0 ] && count="0"
            printf "Installed packages: %s\n" "$count"
            # Last update time for native managers
            if [ -n "$cache_file" ] && [ -e "$cache_file" ]; then
                last_update=$(stat -c %y "$cache_file" 2>/dev/null | cut -d ' ' -f 1,2)
                [ -n "$last_update" ] && printf "Last cache update: %s\n" "$last_update"
            fi
            printf "\n"
            # Store for summary table
            _summary="$manager:$description:$count:$version"
            _summary_list="$_summary_list$_summary\n"
        fi
    }

    # Initialize summary list
    _summary_list=""

    # Native distro package managers
    _check_and_count "dpkg/apt" "dpkg" "sudo dpkg-query -f '\${Package}\n' -W" "apt --version" "Debian/Ubuntu/MX Linux native" "/var/lib/apt/lists"
    _check_and_count "pacman" "pacman" "pacman -Q" "pacman --version | head -n 1" "Arch/Manjaro native" "/var/lib/pacman"
    _check_and_count "rpm" "rpm" "sudo rpm -qa" "rpm --version" "RPM-based (Fedora/CentOS) native" "/var/lib/rpm"
    _check_and_count "dnf" "dnf" "sudo dnf list installed | tail -n +3" "dnf --version | head -n 1" "Fedora native (frontend)" "/var/cache/dnf"
    _check_and_count "yum" "yum" "sudo yum list installed | tail -n +3" "yum --version | head -n 1" "CentOS/RHEL native (frontend)" "/var/cache/yum"
    _check_and_count "zypper" "zypper" "sudo zypper se -i | tail -n +5" "zypper --version" "SUSE native" "/var/cache/zypp"
    _check_and_count "apk" "apk" "apk info" "apk --version" "Alpine native" "/var/cache/apk"
    _check_and_count "portage" "emerge" "ls /var/db/pkg/*/* | wc -l" "emerge --version" "Gentoo native" "/var/db/pkg"
    _check_and_count "nix" "nix-env" "nix-env -q" "nix-env --version" "Nix package manager" "/nix/var/nix/profiles"

    # Universal/cross-distro package managers
    _check_and_count "brew" "brew" "brew list --formulae" "brew --version | head -n 1" "Homebrew (universal)" ""
    _check_and_count "flatpak" "flatpak" "flatpak list --app" "flatpak --version" "Flatpak (universal)" ""
    _check_and_count "snap" "snap" "snap list | tail -n +2" "snap --version" "Snap (universal)" ""

    # Language-specific package managers
    _check_and_count "pip" "pip" "pip list --format=freeze | grep -v '^\\-e'" "pip --version" "Python packages" ""
    _check_and_count "npm" "npm" "npm list -g --depth=0 | tail -n +2" "npm --version" "Node.js global packages" ""
    _check_and_count "cargo" "cargo" "cargo install --list | grep -E '^[a-z0-9_-]+ v[0-9]'" "cargo --version" "Rust crates" ""
    _check_and_count "gem" "gem" "gem list --no-versions" "gem --version" "Ruby gems" ""

    # Print summary table
    if [ -n "$_summary_list" ]; then
        printf "Summary Table:\n"
        printf "+---------------------+------------------------------+-----------------+---------------+\n"
        printf "| %-19s | %-28s | %-15s | %-13s |\n" "Manager" "Description" "Packages" "Version"
        printf "+---------------------+------------------------------+-----------------+---------------+\n"
        printf "%s" "$_summary_list" | while IFS=: read -r manager desc count ver; do
            [ -n "$manager" ] && printf "| %-19s | %-28s | %-15s | %-13s |\n" "$manager" "$desc" "$count" "$ver"
        done
        printf "+---------------------+------------------------------+-----------------+---------------+\n"
    fi

    printf "Detection complete. If a manager is missing, it may not be installed.\n"
    printf "Note: Counts for language managers (e.g., pip) may vary by environment.\n"
}

kern() {
    printf "Kernel Information:\n"
    printf "===================\n"
    # Kernel details
    printf "Kernel Version: %s\n" "$(uname -r)"
    printf "Architecture: %s\n" "$(uname -m)"
    # Loaded modules
    if command -v lsmod >/dev/null 2>&1; then
        module_count=$(lsmod | tail -n +2 | wc -l)
        printf "Loaded Modules: %s\n" "$module_count"
        # Highlight key modules (e.g., network, GPU)
        printf "Key Modules:\n"
        lsmod | grep -E 'wifi|iwlwifi|ath9k|nvidia|amdgpu' | awk '{print $1}'
    else
        printf "Loaded Modules: lsmod not available\n"
    fi
    # Available kernels (distro-specific)
    if [ -d /boot ]; then
        kernels=$(ls /boot/vmlinuz* 2>/dev/null | wc -l)
        printf "Available Kernels: %s\n" "$kernels"
        ls /boot/vmlinuz* 2>/dev/null | sed 's|.*/vmlinuz-||'
    fi
    printf "===================\n"
}

svc() {
    printf "Service Status:\n"
    printf "================\n"
    # Detect init system
    init_system="Unknown"
    if [ -d /run/systemd/system ]; then
        init_system="systemd"
    elif [ -f /sbin/init ] && grep -q sysvinit /sbin/init; then
        init_system="sysVinit"
    elif command -v rc-service >/dev/null 2>&1; then
        init_system="openrc"
    fi
    printf "Init System: %s\n" "$init_system"
    # List services
    case "$init_system" in
        systemd)
            count=$(systemctl list-units --type=service --state=running | grep -c '\.service')
            printf "Running Services: %s\n" "$count"
            systemctl list-units --type=service --state=running | grep '\.service' | awk '{print $1, $3}'
            ;;
        sysVinit)
            count=$(ls /etc/init.d/ | wc -l)
            printf "Service Scripts: %s\n" "$count"
            for svc in /etc/init.d/*; do
                svc_name=$(basename "$svc")
                if /etc/init.d/"$svc_name" status >/dev/null 2>&1; then
                    printf "%s running\n" "$svc_name"
                fi
            done
            ;;
        openrc)
            count=$(rc-service -l | wc -l)
            printf "Running Services: %s\n" "$count"
            rc-service -l | while read -r svc; do
                rc-service "$svc" status | grep -q running && printf "%s running\n" "$svc"
            done
            ;;
        *)
            printf "No supported init system detected.\n"
            ;;
    esac
    printf "================\n"
}
