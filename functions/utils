# print environment
# takes a param that is a string to search for
e() {
    # Define colors
    GREEN="\033[0;32m"
    YELLOW="\033[1;33m"
    NC="\033[0m" # No Color

    # Print matched environment variables with highlighting for the search term
    printenv | grep -i --color=always "$1" | sort

    # Count matches and print the total with color
    matches=$(printenv | grep -i -c "$1")
    printf "${YELLOW}Matches: ${GREEN}${matches}${NC}\n"
}

# display ports (dp)
# dp - Display network listening and active connections with process owner info
#
# This function wraps `netstat -tulanp` to show active TCP/UDP listening and
# connection endpoints, along with the owning user (OWNER) of each process.
#
# Features:
# - If a search term is provided (e.g., port, PID, process name), filters output via `grep`.
# - If no search term is provided, shows all active connections.
# - Parses the PID/Program column to extract the PID and map it to a username via `ps`.
# - Adds an OWNER column to the netstat output.
# - Saves the output to /tmp/dp_matches.log temporarily for counting.
#
# Usage:
#   dp               → list all network connections with owners
#   dp ssh           → filter only lines related to "ssh"
#
# Notes:
# - Requires `sudo` to access process information.
# - Cleans up temporary log file after printing match count.
dp() {
    local search_term="$1"
    local tmpfile="/tmp/dp_matches.log"

    # Run ss to get listening + established sockets with PID info
    local ss_output
    ss_output=$(sudo ss -lntup 2>/dev/null)

    # Skip if no output
    if [[ -z "$ss_output" ]]; then
        echo "No output from ss. Are there any active connections?"
        return 1
    fi

    # Optionally filter
    if [[ -n "$search_term" ]]; then
        echo "Searching for processes matching: $search_term"
        ss_output=$(echo "$ss_output" | grep -i "$search_term")
    else
        echo "Listing all active connections..."
    fi

    if [[ -z "$ss_output" ]]; then
        echo "No matching connections found."
        return 0
    fi

    echo "$ss_output" | while IFS= read -r line; do
        if [[ "$line" =~ ^Netid ]]; then
            echo -e "${line}\tOWNER"
        elif [[ -n "$line" ]]; then
            local pid=$(echo "$line" | grep -oP 'pid=\K[0-9]+')
            if [[ "$pid" =~ ^[0-9]+$ ]]; then
                local owner=$(ps -o user= -p "$pid" 2>/dev/null || echo "N/A")
                echo -e "${line}\t${owner}"
            else
                echo -e "${line}\tN/A"
            fi
        fi
    done | tee "$tmpfile"

    local match_count
    match_count=$(wc -l < "$tmpfile")
    echo "Matches: $match_count"
    rm -f "$tmpfile"
}

