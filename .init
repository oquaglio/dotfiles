# DISPLAY SHELL INFO ############################################################################
if [ -n "$BASH_VERSION" ]; then
    echo "This is Bash ($BASH_VERSION)."
fi

if [ -n "$ZSH_VERSION" ]; then
    echo "This is Zsh ($ZSH_VERSION)."    
fi


# SET CORE ENV ##################################################################################
export DOTFILES_USER=oquaglio
export DOTFILES_LOCAL_ROOT=$HOME/.dotfiles-local


# Housekeeping #################################################################################
chmod +x $DOTFILES_ROOT/scripts/create_symlinks.sh && $DOTFILES_ROOT/scripts/create_symlinks.sh
chmod +x $DOTFILES_ROOT/bin/*
mkdir -p $DOTFILES_LOCAL_ROOT


# DEFINE CORE FUNCTIONS #########################################################################

#reload (re-source) shell config files
reload_shell_config() {
    if [ -n "$ZSH_VERSION" ] && [ -r ~/.zshrc ]; then
	# echo "Reloading .zshrc..."
        . ~/.zshrc
	# https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file
	#echo 'Running "exec zsh"...'
	#exec zsh
    fi

    if [ -n "$BASH_VERSION" ] && [ -r ~/.bashrc ]; then
	#echo "Reloading .bashrc..."
        . ~/.bashrc
    fi
}
alias rl='reload_shell_config'

# Add a directory to a PATH-like variable if it's not already present.
# Usage:
#   pathadd /some/dir            # Appends to PATH
#   pathadd /some/dir PATH       # Appends to PATH
#   pathadd /some/dir PATH prepend  # Prepends to PATH
#   pathadd /some/dir MY_PATH append # Appends to MY_PATH
pathadd() {
    local dir_to_add="$1"
    local path_var="${2:-PATH}"
    local position="${3:-append}"

    # Check if the directory exists
    if [ -d "$dir_to_add" ]; then
        # Retrieve the current value of the specified path variable
        local current_path
        current_path="$(eval echo "\$$path_var")"

        # Remove all existing instances of the directory
        local path_entry
        local new_path=""
        IFS=':' read -ra path_entries <<< "$current_path"
        for path_entry in "${path_entries[@]}"; do
            if [ "$path_entry" != "$dir_to_add" ]; then
                if [ -z "$new_path" ]; then
                    new_path="$path_entry"
                else
                    new_path="$new_path:$path_entry"
                fi
            fi
        done

        # Add the directory to the path variable based on the specified position
        if [ "$position" = "prepend" ]; then
            new_path="$dir_to_add${new_path:+:$new_path}"
        else
            new_path="${new_path:+$new_path:}$dir_to_add"
        fi

        # Export the updated path variable
        eval export "$path_var=\"$new_path\""
    fi
}

# set env variable to dir IF dir exists
# $1 = env var
# $2 = dir
setenv() {
	if [ -d "$2" ]; then
		export $1=$2
	fi
}

contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# Function to safely source a file if it exists
source_if_exists() {
    local filename="$1"  # Capture the filename argument

    # Check if the file exists and is readable
    if [[ -r "$filename" ]]; then
        #echo "Sourcing: $filename... "
        source "$filename"
    else
        echo "Error: $filename does not exist or is not readable."
    fi
}

# Function to source files from a specified root directory and pattern
source_files() {
    local search_dir="$1"  # Directory to search in
    local file_pattern="$2"  # File pattern to match

    #echo "source_files invoked with: $search_dir $file_pattern"

    # Check if parameters are provided
    if [[ -z "$search_dir" || -z "$file_pattern" ]]; then
        echo "Error: Both directory path and file pattern must be provided."
        return 1  # Return with an error status
    elif [[ ! -d "$search_dir" ]]; then
        echo "Error: Provided path '$search_dir' is not a directory."
        return 1
    fi

    # Finding and sourcing files based on the given pattern
    local file
    while IFS= read -r file; do
        if [[ -r "$file" ]]; then  # Check if the file is readable
            #echo "Sourcing: $file... "
            source "$file"
        else
            echo "Warning: '$file' is not readable and will not be sourced."
        fi
    done < <(find "$search_dir" -type f -name "$file_pattern")

    #echo "All applicable files sourced based on pattern '$file_pattern'."
}

# Function to run a command only if it exists
run_if_exists() {
    if command -v "$1" >/dev/null 2>&1; then
        # echo "Running $1..."
        "$@"
    else
        # echo "$1 not found, doing nothing."
	:
    fi
}

